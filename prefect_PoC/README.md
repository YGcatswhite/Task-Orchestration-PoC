# Prefect

![img](https://pic2.zhimg.com/80/v2-a7d3f09697e2ecabcbf19a70f1b972a5_1440w.jpg)

**对于流的定义和使用非常灵活**

Prefect独特的混合执行模型可以让代码和数据完全私密，同时可以充分利用弱冠的编排服务

当注册工作流的时候，代码会安全地存储在基础设施中。工作流元数据被发送到Prefect Cloud以进行调度和编排。Prefect Agent在用户的部署架构中运行，负责启动和监控工作流运行。Agent向Prefect Cloud API发送请求来更新工作流运行元数据。

Agent负责启动和监控工作流运行。Prefect 支持多种不同的代理类型，用于在不同平台上进行部署：

- 本地代理作为本地进程执行工作流
- Docker代理在Docker容器中执行工作流
- K8S代理将工作流作为K8S作业执行
- AES ECS：ECS代理将工作流运行作为AWS ECS任务执行

## Home

在Prefect 工作流中你可以使用本地代码，你可以选择要向编排的API中注册的工作流代码中的哪些单个元素；工作流可以包括在运行时确定执行路径的逻辑，使用本地狗仔和Prefect构造均可以；可以随时修改工作流，可以使用自定义运行时参数运行工作流和任务、随时更改计划、执行临时运行，甚至生成流运行以相应运行时条件或者流事件

### 基本编排

使用装饰函数，可以在失败时重试它们

可以通过更改流的task_runner，使用DaskTaskRunner，将自动提交以Dask.distributed集群上并行运行

可以进行异步并发：

## 入门

### 安装

```python
pip install -U "prefect>=2.0b"
pip install -U "prefect==2.0b8"
pip install git+https://github.com/PrefectHQ/prefect@orion
```

### 教程

和airflow很像，流是用装饰器装饰的Python函数@flow，任务是用装饰器装饰的函数@task

**在流中定义流，这个特点留意一下**

异步函数也可以和Prefect一起使用，其它框架中没有提供类似需求

#### 任务依赖

wait_for

#### 流程执行

可以有任务执行者，通过任务执行器的概念公开此功能，并行执行DaskTaskRunner（它`DaskTaskRunner`会自动创建一个本地 Dask 集群，然后立即开始并行执行所有任务。使用的工作人员数量取决于您机器上的内核数量），使用async和await就可以进行异步运行



## 概念

### Flow

流是唯一可以交互、显示和运行的Prefect抽象，流是工作流逻辑的容器，允许用户预期工作流状态进行交互与推断

流就像函数，可以接受输入、执行工作并返回输出

流有以下参数：

| 争论                  | 描述                                                         |
| :-------------------- | :----------------------------------------------------------- |
| `description`         | 流的可选字符串描述。如果未提供，将从装饰函数的文档字符串中提取描述。 |
| `name`                | 流的可选名称。如果未提供，则将从函数中推断名称。             |
| `retries`             | 在流运行失败时重试的可选次数。                               |
| `retry_delay_seconds` | 在失败后重试流之前等待的可选秒数。这仅适用于`retries`非零值。 |
| `task_runner`         | 用于在流中执行任务的[任务](https://orion-docs.prefect.io/concepts/task-runners/)运行器。如果未提供，`ConcurrentTaskRunner`将使用。 |
| `timeout_seconds`     | 可选的秒数，指示流的最大运行时间。如果流超过此运行时间，它将被标记为失败。流程执行可能会继续，直到调用下一个任务。 |
| `validate_parameters` | 指示传递给流的参数是否由 Pydantic 验证的布尔值。默认为`True`。 |
| `version`             | 流的可选版本字符串。如果未提供，我们将尝试创建一个版本字符串作为包含包装函数的文件的哈希。如果找不到文件，则版本将为空。 |

当在另一个流的执行中调用流函数时，将创建子流运行。主要流程是父流程，子流运行的行为类似于正常的流运行。在后端运行的流程有完整的表示，就好像它被单独调用一样。当子流启动时，它将创建一个新的任务运行器，并且子流中的任务将提交给它。子流完成后，任务运行器将关闭。

#### Task

如果任何一行代码失败，整个任务都会失败，必须从头开始重试。这可以通过将代码拆分为多个相关任务来避免。

| 争论                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| 姓名                | 任务的可选名称。如果未提供，则将从函数名称推断名称。         |
| 描述                | 任务的可选字符串描述。                                       |
| 标签                | 与此任务的运行相关联的一组可选标签。`prefect.tags`这些标签与任务运行时上下文定义的任何标签组合在一起。 |
| cache_key_fn        | 一个可选的可调用对象，给定任务运行上下文和调用参数，生成一个字符串键。如果密钥与先前的已完成状态匹配，则将恢复该状态结果，而不是再次运行任务。 |
| 缓存过期            | 一个可选的时间量，指示该任务的缓存状态应该可以恢复多长时间；如果未提供，缓存状态将永远不会过期。 |
| 重试                | 重试任务运行失败的可选次数。                                 |
| retry_delay_seconds | 失败后重试任务之前等待的可选秒数。这仅适用于`retries`非零值。 |
| 版本                | 一个可选字符串，指定此任务定义的版本。                       |

缓存是指任务运行反映完成状态而不实际运行定义任务的代码的能力。这使您可以有效地重用每次流运行时运行成本可能很高的任务的结果，或者如果任务的输入没有更改，则重用缓存的结果。